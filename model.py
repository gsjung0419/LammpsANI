#Generated by GS JUNG@ORNL and HJ MYUNG@KISTI
from __future__ import print_function
import torch,os
import torchani
from torchani.utils import ChemicalSymbolsToInts
import sys

device_str = 'cpu'

class Model:
	def __init__(self):
		try: 
			path=os.path.dirname(os.path.realpath(__file__))
		except NameError:
			path=os.getcwd()
		sae_file = os.path.join(path, 'sae_linfit_dftb.data')  
		const_file = os.path.join(path, 'rC.params')
		consts = torchani.neurochem.Constants(const_file)
		self.aev_computer = torchani.AEVComputer(**consts)
		self.energy_shifter = torchani.neurochem.load_sae(sae_file)

		species_order = ['C']
		num_species = len(species_order)
#########################Set UP AEV#################################
		self.species_to_tensor = ChemicalSymbolsToInts(species_order)
		aev_dim = self.aev_computer.aev_length
###############################################################################
# The code to define networks
		C_network = torch.nn.Sequential(
				torch.nn.Linear(aev_dim, 224),
				torch.nn.GELU(),
				torch.nn.Linear(224, 192),
				torch.nn.GELU(),
				torch.nn.Linear(192, 160),
				torch.nn.GELU(),
				torch.nn.Linear(160, 1)
)

		self.nn = torchani.ANIModel([C_network])
		self.nn.load_state_dict(torch.load('force-training-best.pt',map_location=device_str))
		self.model = torchani.nn.Sequential(self.aev_computer,self.nn,self.energy_shifter).to(device_str).to(torch.float64)
		self.count=0


	# for debugging 
	def check(self):
		self.count=self.count+1
		return self.count


#if __name__=='__main__':
#	m=Model()
#	print("\t{}".format(m.model))
#	print("Success!")
